# ==============================================================================
# Application Configuration - This is the main place where you define your application
# ==============================================================================
# ‚ö†Ô∏è Important Notice:
# Some sections in this file are shown with empty curly braces {} or brackets [] as placeholders.
# When you need to configure those sections, remove the {} or [] and replace them with proper YAML indentation.
# Example:
#   resources:
#     requests:
#       cpu: "250m"
#       memory: "256Mi"
#     limits:
#       cpu: "500m"
#       memory: "512Mi"
# This ensures correct YAML syntax and prevents Helm deployment errors.


# ------------------------------------------------------------------------------
# App Identification
# ------------------------------------------------------------------------------
# nameOverride: ""  # ‚ö†Ô∏è Change only if needed - overrides the Chart name
# fullnameOverride: ""  # ‚ö†Ô∏è Change only if needed - overrides the full name (release-name + app-name)

# ------------------------------------------------------------------------------
# Labels - Identifies the application in the platform
# ------------------------------------------------------------------------------
labels:
  managedBy: "weaversoft-platform"  # ‚úÖ Don't change - identifies that the app is managed by the platform
  owner: "default"  # üîß Change! - Set the team/owner name (e.g., "backend-team", "data-science")
  dcsIngress:
    enabled: true  # ‚úÖ true = app will be exposed via HTTPRoute (Kyverno creates HTTPRoute automatically for NGINX Gateway Fabric)
    host: ""  # üîß Change! - Domain name (e.g., "my-app.example.com") - if empty, Kyverno will set automatically
    path: "/"  # üîß Change! - URL path (e.g., "/api/v1" or "/app")
    tls: true  # ‚úÖ true = use cluster-wide TLS certificate (managed by NGINX Gateway Fabric)
    # üìù Note: Kyverno reads these labels and creates HTTPRoute with TLS automatically

# ------------------------------------------------------------------------------
# Docker Image - ‚ö†Ô∏è Must change!
# ------------------------------------------------------------------------------
image:
  repository: "registry.example.com/org/app"  # üîß Must change! - Your registry address (e.g., "registry.company.com/my-team/my-app")
  tag: "v1.0.0"  # üîß Change! - Image tag (recommended: git-sha or semver like "1.0.0", not "latest" for production)
  pullPolicy: IfNotPresent  # ‚úÖ Usually no need to change (Always = always pull, IfNotPresent = only if not exists)
  pullSecrets: []  # üîß If private registry - add a list of secret names (e.g., ["regcred"])

# ------------------------------------------------------------------------------
# Replica Count
# ------------------------------------------------------------------------------
replicaCount: 1  # üîß Change! - Number of pods to run (1 for staging, 2+ for production for high availability)

# ------------------------------------------------------------------------------
# Kubernetes Service - Important to configure correctly!
# ------------------------------------------------------------------------------
service:
  type: ClusterIP  # ‚úÖ Usually ClusterIP - no need to change (NodePort/LoadBalancer only needed in special cases)
  port: 80  # üîß Change! - Port that the application listens on in the container (e.g., 3000, 8080, 5000)
  annotations: {}  # üîß Add special annotations if needed (e.g., load balancer annotations)

# ------------------------------------------------------------------------------
# Additional Annotations and Labels for Pod
# ------------------------------------------------------------------------------
podAnnotations: {}  # üîß Add pod annotations if needed (e.g., prometheus.io/scrape: "true")
podLabels: {}  # üîß Add additional pod labels if needed

# ------------------------------------------------------------------------------
# Compute Resources - ‚ö†Ô∏è Important to configure for production!
# ------------------------------------------------------------------------------
resources:  # üîß Must change for production! - Set limits and requests:
  requests:
    cpu: "250m"     # Minimum CPU
    memory: "256Mi" # Minimum memory
  limits:
    cpu: "500m"     # Maximum CPU
    memory: "512Mi" # Maximum memory

# ------------------------------------------------------------------------------
# Security - Pod Security Context (Pod level)
# ------------------------------------------------------------------------------
securityContext:
  enabled: true  # ‚úÖ Recommended to keep true - enables advanced security
  runAsNonRoot: true  # ‚úÖ Don't change - runs as regular user, not root (security)
  runAsUser: 10001  # üîß Change if app requires specific user (recommended 10001+)
  runAsGroup: 10001  # üîß Change if app requires specific group
  fsGroup: 10001  # üîß Change if volumes need specific permissions

# ------------------------------------------------------------------------------
# Security - Container Security Context (Container level)
# ------------------------------------------------------------------------------
containerSecurityContext:
  readOnlyRootFilesystem: true  # üîß Change to false if app needs to write to root filesystem
  allowPrivilegeEscalation: false  # ‚úÖ Don't change - prevents privilege escalation
  capabilities:
    drop: ["ALL"]  # ‚úÖ Don't change - drops all capabilities (maximum security)
    # üîß If app needs specific capabilities:
    # drop: ["ALL"]
    # add: ["NET_BIND_SERVICE"]  # Example

# ------------------------------------------------------------------------------
# Pod Placement - Where to run the Pods
# ------------------------------------------------------------------------------
nodeSelector: {}  # üîß Add if need pods on specific nodes (e.g., {"disktype": "ssd"})
affinity: {}  # üîß Add advanced affinity/anti-affinity rules if needed
tolerations: []  # üîß Add if need to run on nodes with taints

# ------------------------------------------------------------------------------
# Environment Variables
# ------------------------------------------------------------------------------
env: []  # üîß Add environment variables:
  # - name: DATABASE_URL
  #   value: "postgresql://host:5432/db"
  # - name: LOG_LEVEL
  #   value: "info"
envFrom: []  # üîß Add if need to load variables from ConfigMap or Secret:
  # - configMapRef:
  #     name: my-config
  # - secretRef:
  #     name: my-secret

# ------------------------------------------------------------------------------
# Configuration Files - ConfigMap
# ------------------------------------------------------------------------------
config:
  enabled: false  # üîß Change to true if need to mount config files
  data: {}  # üîß If enabled: true, add config files here:
  # app.properties: |
  #   ENV=production
  #   LOG_LEVEL=info
  # config.yaml: |
  #   server:
  #     port: 8080
  # üìù Files will be mounted to /app/config in the container

# ------------------------------------------------------------------------------
# Service Account - RBAC and Pod Identity
# ------------------------------------------------------------------------------
# üìù Note: To use an existing ServiceAccount, specify its name below
# üìù To create a new ServiceAccount, add a serviceaccount.yaml template file
serviceAccount:
  name: ""  # üîß Specify existing ServiceAccount name if needed (e.g., "my-app-sa")

# ------------------------------------------------------------------------------
# Health Checks - ‚ö†Ô∏è Critical for production!
# ------------------------------------------------------------------------------
# Liveness probe - Kubernetes restarts container if this fails
livenessProbe: {}  # üîß Add health check configuration:
  # httpGet:
  #   path: /health
  #   port: 80  # Use same port as service.port
  # initialDelaySeconds: 30
  # periodSeconds: 10
  # timeoutSeconds: 5
  # failureThreshold: 3
  # Or use tcpSocket:
  # tcpSocket:
  #   port: 80  # Use same port as service.port
  # Or use exec:
  # exec:
  #   command: ["/bin/sh", "-c", "check-health.sh"]

# Readiness probe - Pod not receiving traffic until this passes
readinessProbe: {}  # üîß Add readiness check:
  # httpGet:
  #   path: /ready
  #   port: 80  # Use same port as service.port
  # initialDelaySeconds: 5
  # periodSeconds: 5
  # timeoutSeconds: 3
  # failureThreshold: 3

# Startup probe - For slow-starting applications
startupProbe: {}  # üîß Add startup check (for apps that take >30s to start):
  # httpGet:
  #   path: /health
  #   port: 80  # Use same port as service.port
  # initialDelaySeconds: 0
  # periodSeconds: 10
  # timeoutSeconds: 3
  # failureThreshold: 30  # 5 minutes total

# ------------------------------------------------------------------------------
# Lifecycle Hooks
# ------------------------------------------------------------------------------
lifecycle: {}  # üîß Add lifecycle hooks if needed:
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "sleep 15"]  # Graceful shutdown
  # postStart:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo 'Container started'"]

# ------------------------------------------------------------------------------
# Init Containers - Run before main container starts
# ------------------------------------------------------------------------------
initContainers: []  # üîß Add init containers if needed:
  # - name: wait-for-db
  #   image: busybox:1.35
  #   command: ['sh', '-c', 'until nc -z database 5432; do sleep 1; done']
  # - name: migrate-database
  #   image: "registry.example.com/org/app:v1.0.0"  # Use your image repository and tag
  #   command: ['npm', 'run', 'migrate']

# ------------------------------------------------------------------------------
# Persistent Storage - PVC (PersistentVolumeClaim)
# ------------------------------------------------------------------------------
# üìù Note: To use persistent storage, create a pvc.yaml template file
# üìù Then mount it using extraVolumes and extraVolumeMounts below
# persistence:
#   enabled: true
#   size: 10Gi
#   storageClassName: ""
#   accessModes: ["ReadWriteOnce"]

# ------------------------------------------------------------------------------
# Extra Volumes and Volume Mounts
# ------------------------------------------------------------------------------
extraVolumes: []  # üîß Add additional volumes if needed:
  # - name: tmp
  #   emptyDir: {}
  # - name: logs
  #   hostPath:
  #     path: /var/log/app

extraVolumeMounts: []  # üîß Add additional volume mounts:
  # - name: tmp
  #   mountPath: /tmp
  # - name: logs
  #   mountPath: /var/log

# ------------------------------------------------------------------------------
# Pod Disruption Budget - High Availability
# ------------------------------------------------------------------------------
# üìù Note: To enable PDB, create a pdb.yaml template file
# üìù Useful for production with replicaCount > 1
# podDisruptionBudget:
#   enabled: true
#   minAvailable: "1"  # or maxUnavailable: "1"

# ------------------------------------------------------------------------------
# Internet Exposure (HTTPRoute via Kyverno + NGINX Gateway Fabric)
# ------------------------------------------------------------------------------
# ‚ö†Ô∏è Important: HTTPRoute is created automatically by Kyverno, no need to create manually!
# 
# How it works:
# 1. When labels.dcsIngress.enabled = true:
#    - Service gets annotation "expose: true" (triggers Kyverno)
#    - Service gets labels: dcs.ingress/enabled, dcs.ingress/host, dcs.ingress/path, dcs.ingress/tls
# 2. Kyverno reads the annotation and labels
# 3. Kyverno creates HTTPRoute automatically
# 4. NGINX Gateway Fabric uses the HTTPRoute to route traffic
# 5. TLS is handled automatically using cluster-wide certificate
#
# üìù Note: All HTTPRoute configuration is in labels.dcsIngress above!
#    When labels.dcsIngress.enabled = true, everything happens automatically.

